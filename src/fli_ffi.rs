/* automatically generated by rust-bindgen 0.68.1 */

pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const FLI_INVALID_DEVICE: i32 = -1;
pub const FLIDOMAIN_NONE: u32 = 0;
pub const FLIDOMAIN_PARALLEL_PORT: u32 = 1;
pub const FLIDOMAIN_USB: u32 = 2;
pub const FLIDOMAIN_SERIAL: u32 = 3;
pub const FLIDOMAIN_INET: u32 = 4;
pub const FLIDOMAIN_SERIAL_19200: u32 = 5;
pub const FLIDOMAIN_SERIAL_1200: u32 = 6;
pub const FLIDOMAIN_INTERFACE_MASK: u32 = 15;
pub const FLIDEVICE_NONE: u32 = 0;
pub const FLIDEVICE_CAMERA: u32 = 256;
pub const FLIDEVICE_FILTERWHEEL: u32 = 512;
pub const FLIDEVICE_FOCUSER: u32 = 768;
pub const FLIDEVICE_HS_FILTERWHEEL: u32 = 1024;
pub const FLIDEVICE_RAW: u32 = 3840;
pub const FLIDOMAIN_DEVICE_MASK: u32 = 3840;
pub const FLIDEVICE_ENUMERATE_BY_CONNECTION: u32 = 32768;
pub const FLIDEVICE_ENUMERATE_BY_SERIAL: u32 = 32768;
pub const FLIDOMAIN_OPTIONS_MASK: u32 = 61440;
pub const FLI_FRAME_TYPE_NORMAL: u32 = 0;
pub const FLI_FRAME_TYPE_DARK: u32 = 1;
pub const FLI_FRAME_TYPE_FLOOD: u32 = 2;
pub const FLI_FRAME_TYPE_RBI_FLUSH: u32 = 3;
pub const FLI_MODE_8BIT: u32 = 0;
pub const FLI_MODE_16BIT: u32 = 1;
pub const FLI_SHUTTER_CLOSE: u32 = 0;
pub const FLI_SHUTTER_OPEN: u32 = 1;
pub const FLI_SHUTTER_EXTERNAL_TRIGGER: u32 = 2;
pub const FLI_SHUTTER_EXTERNAL_TRIGGER_LOW: u32 = 2;
pub const FLI_SHUTTER_EXTERNAL_TRIGGER_HIGH: u32 = 4;
pub const FLI_SHUTTER_EXTERNAL_EXPOSURE_CONTROL: u32 = 8;
pub const FLI_BGFLUSH_STOP: u32 = 0;
pub const FLI_BGFLUSH_START: u32 = 1;
pub const FLI_TEMPERATURE_INTERNAL: u32 = 0;
pub const FLI_TEMPERATURE_EXTERNAL: u32 = 1;
pub const FLI_TEMPERATURE_CCD: u32 = 0;
pub const FLI_TEMPERATURE_BASE: u32 = 1;
pub const FLI_CAMERA_STATUS_UNKNOWN: u32 = 4294967295;
pub const FLI_CAMERA_STATUS_MASK: u32 = 3;
pub const FLI_CAMERA_STATUS_IDLE: u32 = 0;
pub const FLI_CAMERA_STATUS_WAITING_FOR_TRIGGER: u32 = 1;
pub const FLI_CAMERA_STATUS_EXPOSING: u32 = 2;
pub const FLI_CAMERA_STATUS_READING_CCD: u32 = 3;
pub const FLI_CAMERA_DATA_READY: u32 = 2147483648;
pub const FLI_FOCUSER_STATUS_UNKNOWN: u32 = 4294967295;
pub const FLI_FOCUSER_STATUS_HOMING: u32 = 4;
pub const FLI_FOCUSER_STATUS_MOVING_IN: u32 = 1;
pub const FLI_FOCUSER_STATUS_MOVING_OUT: u32 = 2;
pub const FLI_FOCUSER_STATUS_MOVING_MASK: u32 = 7;
pub const FLI_FOCUSER_STATUS_HOME: u32 = 128;
pub const FLI_FOCUSER_STATUS_LIMIT: u32 = 64;
pub const FLI_FOCUSER_STATUS_LEGACY: u32 = 268435456;
pub const FLI_FILTER_WHEEL_PHYSICAL: u32 = 256;
pub const FLI_FILTER_WHEEL_VIRTUAL: u32 = 0;
pub const FLI_FILTER_WHEEL_LEFT: u32 = 256;
pub const FLI_FILTER_WHEEL_RIGHT: u32 = 257;
pub const FLI_FILTER_STATUS_MOVING_CCW: u32 = 1;
pub const FLI_FILTER_STATUS_MOVING_CW: u32 = 2;
pub const FLI_FILTER_POSITION_UNKNOWN: u32 = 255;
pub const FLI_FILTER_POSITION_CURRENT: u32 = 512;
pub const FLI_FILTER_STATUS_HOMING: u32 = 4;
pub const FLI_FILTER_STATUS_HOME: u32 = 128;
pub const FLI_FILTER_STATUS_HOME_LEFT: u32 = 128;
pub const FLI_FILTER_STATUS_HOME_RIGHT: u32 = 64;
pub const FLI_FILTER_STATUS_HOME_SUCCEEDED: u32 = 8;
pub const FLIDEBUG_NONE: u32 = 0;
pub const FLIDEBUG_INFO: u32 = 1;
pub const FLIDEBUG_WARN: u32 = 2;
pub const FLIDEBUG_FAIL: u32 = 4;
pub const FLIDEBUG_IO: u32 = 8;
pub const FLIDEBUG_ALL: u32 = 7;
pub const FLI_IO_P0: u32 = 1;
pub const FLI_IO_P1: u32 = 2;
pub const FLI_IO_P2: u32 = 4;
pub const FLI_IO_P3: u32 = 8;
pub const FLI_FAN_SPEED_OFF: u32 = 0;
pub const FLI_FAN_SPEED_ON: u32 = 4294967295;
pub const FLI_EEPROM_USER: u32 = 0;
pub const FLI_EEPROM_PIXEL_MAP: u32 = 1;
pub const FLI_PIXEL_DEFECT_COLUMN: u32 = 0;
pub const FLI_PIXEL_DEFECT_CLUSTER: u32 = 16;
pub const FLI_PIXEL_DEFECT_POINT_BRIGHT: u32 = 32;
pub const FLI_PIXEL_DEFECT_POINT_DARK: u32 = 48;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " @brief An opaque handle used by library functions to refer to FLI hardware.\n"]
pub type flidev_t = ::std::os::raw::c_long;
#[doc = " @brief The domain of an FLI device.  This consists of a bitwise ORed\n combination of interface method and device type.  Valid interfaces\n are \\texttt{FLIDOMAIN_PARALLEL_PORT}, \\texttt{FLIDOMAIN_USB},\n \\texttt{FLIDOMAIN_SERIAL}, and \\texttt{FLIDOMAIN_INET}.  Valid\n device types are \\texttt{FLIDEVICE_CAMERA},\n \\texttt{FLIDOMAIN_FILTERWHEEL}, and \\texttt{FLIDOMAIN_FOCUSER}.\n\n @see FLIOpen\n @see FLIList\n"]
pub type flidomain_t = ::std::os::raw::c_long;
#[doc = " @brief The frame type for an FLI CCD camera device.  Valid frame types are\n #FLI_FRAME_TYPE_NORMAL and #FLI_FRAME_TYPE_DARK.\n @link FLISetFrameType"]
pub type fliframe_t = ::std::os::raw::c_long;
#[doc = "The gray-scale bit depth for an FLI camera device.  Valid bit\ndepths are \\texttt{FLI_MODE_8BIT} and \\texttt{FLI_MODE_16BIT}.\n\n@see FLISetBitDepth"]
pub type flibitdepth_t = ::std::os::raw::c_long;
#[doc = " @brief Type used for shutter operations for an FLI camera device.  Valid\n shutter types are FLI_SHUTTER_CLOSE,\n FLI_SHUTTER_OPEN,\n FLI_SHUTTER_EXTERNAL_TRIGGER,\n FLI_SHUTTER_EXTERNAL_TRIGGER_LOW, and\n FLI_SHUTTER_EXTERNAL_TRIGGER_HIGH.\n\n @see FLIControlShutter\n"]
pub type flishutter_t = ::std::os::raw::c_long;
#[doc = "Type used for background flush operations for an FLI camera device.  Valid\nbgflush types are \\texttt{FLI_BGFLUSH_STOP} and\n\\texttt{FLI_BGFLUSH_START}.\n\n@see FLIControlBackgroundFlush"]
pub type flibgflush_t = ::std::os::raw::c_long;
#[doc = "Type used to determine which temperature channel to read.  Valid\nchannel types are \\texttt{FLI_TEMPERATURE_INTERNAL} and\n\\texttt{FLI_TEMPERATURE_EXTERNAL}.\n\n@see FLIReadTemperature"]
pub type flichannel_t = ::std::os::raw::c_long;
#[doc = "Type specifying library debug levels.  Valid debug levels are\n\\texttt{FLIDEBUG_NONE}, \\texttt{FLIDEBUG_INFO},\n\\texttt{FLIDEBUG_WARN}, and \\texttt{FLIDEBUG_FAIL}.\n\n@see FLISetDebugLevel"]
pub type flidebug_t = ::std::os::raw::c_long;
pub type flimode_t = ::std::os::raw::c_long;
pub type flistatus_t = ::std::os::raw::c_long;
pub type flitdirate_t = ::std::os::raw::c_long;
pub type flitdiflags_t = ::std::os::raw::c_long;
extern "C" {
    pub fn FLIDebug(level: ::std::os::raw::c_int, format: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " @brief Get a handle to an FLI device. This function requires the filename and domain of the requested device. Valid device filenames can be obtained using the `FLIList()` function. An application may use any number of handles associated with the same physical device. When doing so, it is important to lock the appropriate device to ensure that multiple accesses to the same device do not occur during critical operations.\n\n @param dev Pointer to where a handle to the device will be stored.\n @param name Pointer to a string where the device filename to be opened is stored.\n For parallel port devices that are not probed by `FLIList()` (Win 9x), place the address of the parallel port in a string in ASCII form, e.g. \"0x378\".\n @param domain Domain to apply to `name` for device opening. This is a bitwise OR of the interface method and device type. Valid interfaces are `FLIDOMAIN_PARALLEL_PORT`, `FLIDOMAIN_USB`, `FLIDOMAIN_SERIAL`, and `FLIDOMAIN_INET`. Valid device types are `FLIDEVICE_CAMERA`, `FLIDOMAIN_FILTERWHEEL`, and `FLIDOMAIN_FOCUSER`.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIOpen(
        dev: *mut flidev_t,
        name: *mut ::std::os::raw::c_char,
        domain: flidomain_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Enable debugging of API operations and communications. Use this function in\n combination with FLIDebug to assist in diagnosing problems that may be encountered\n during programming.\n\n When usings Microsoft Windows operating systems, creating an empty file\n `C:\\\\FLIDBG.TXT` will override this option. All debug output will then\n be directed to this file.\n\n @param host Name of the file to send debug output to. This parameter is ignored on Linux where `syslog(3)` is used to send debug output to the system log (see `syslog.conf(5)` to confugure `syslogd`).\n @param level Debug level. This parameter is a bitwise OR of the following values:\n - `FLIDEBUG_NONE` - No debug output.\n - `FLIDEBUG_INFO` - Informational messages.\n - `FLIDEBUG_WARN` - Warning messages.\n - `FLIDEBUG_FAIL` - Error messages.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLISetDebugLevel(
        host: *mut ::std::os::raw::c_char,
        level: flidebug_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Close a handle to an FLI device. This function releases the handle to the device and frees any resources associated with it.\n\n @param dev Handle to the device to close.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIClose(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the current library version. This function copies up to `len - 1` characters of the library version string to the buffer pointed to by `ver`. The string is null-terminated.\n\n @param ver Pointer to a character buffer where the library version string will be stored.\n @param len The size of the buffer in bytes.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetLibVersion(ver: *mut ::std::os::raw::c_char, len: usize)
        -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the model of a given device. This function copies up to `len - 1` characters of the device model string to the buffer pointed to by `model`. The string is null-terminated.\n\n @param dev Device handle.\n @param model Pointer to a character buffer where the device model string will be stored.\n @param len The size of the buffer in bytes.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetModel(
        dev: flidev_t,
        model: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Find the dimensions of a pixel in the device's CCD array. This function returns the dimensions of a pixel in the device's CCD array in microns. The values are stored in the variables pointed to by `pixel_x` and `pixel_y`.\n\n @param dev Camera handle.\n @param pixel_x Pointer to a double where the pixel width will be stored.\n @param pixel_y Pointer to a double where the pixel height will be stored.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetPixelSize(
        dev: flidev_t,
        pixel_x: *mut f64,
        pixel_y: *mut f64,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the hardware revision of a given device. This function returns the hardware revision of the device in the variable pointed to by `hwrev`.\n\n @param dev Device handle.\n @param hwrev Pointer to a long where the hardware revision will be stored.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetHWRevision(
        dev: flidev_t,
        hwrev: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the firmware revision of a given device. This function returns the firmware revision of the device in the variable pointed to by `fwrev`.\n\n @param dev Device handle.\n @param fwrev Pointer to a long where the firmware revision will be stored.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetFWRevision(
        dev: flidev_t,
        fwrev: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the array area of a given device. This function returns the array area of the device in the variables pointed to by `ul_x`, `ul_y`, `lr_x`, and `lr_y`.\n\n @param dev Camera handle.\n @param ul_x Upper-left x-coordinate.\n @param ul_y Upper-left y-coordinate.\n @param lr_x Lower-right x-coordinate.\n @param lr_y Lower-right y-coordinate.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetArrayArea(
        dev: flidev_t,
        ul_x: *mut ::std::os::raw::c_long,
        ul_y: *mut ::std::os::raw::c_long,
        lr_x: *mut ::std::os::raw::c_long,
        lr_y: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the visible area of a given device. This function returns the visible area of the device in the variables pointed to by `ul_x`, `ul_y`, `lr_x`, and `lr_y`.\n\n @param dev Camera handle.\n @param ul_x Upper-left x-coordinate.\n @param ul_y Upper-left y-coordinate.\n @param lr_x Lower-right x-coordinate.\n @param lr_y Lower-right y-coordinate.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetVisibleArea(
        dev: flidev_t,
        ul_x: *mut ::std::os::raw::c_long,
        ul_y: *mut ::std::os::raw::c_long,
        lr_x: *mut ::std::os::raw::c_long,
        lr_y: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the exposure time for a given device. This function sets the exposure time for the device to `exptime` milliseconds.\n\n @param dev Camera handle.\n @param exptime Exposure time in milliseconds.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLISetExposureTime(
        dev: flidev_t,
        exptime: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the region of interest for a given device. This function sets the region of interest for the device to the rectangle defined by the upper-left corner `(ul_x, ul_y)` and the lower-right corner `(lr_x, lr_y)`.\n\n @param dev Camera handle.\n @param ul_x Upper-left x-coordinate (unbinned coordinates).\n @param ul_y Upper-left y-coordinate (unbinned coordinates).\n @param lr_x Lower-right x-coordinate (binned coordinates).\n @param lr_y Lower-right y-coordinate (binned coordinates).\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLISetImageArea(
        dev: flidev_t,
        ul_x: ::std::os::raw::c_long,
        ul_y: ::std::os::raw::c_long,
        lr_x: ::std::os::raw::c_long,
        lr_y: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the horizontal binning for a given device. This function sets the horizontal binning for the device to `hbin`.\n\n @param dev Camera handle.\n @param hbin Horizontal bin value. Valid values are between 1 and 16.\n @return LIBFLIAPI"]
    pub fn FLISetHBin(dev: flidev_t, hbin: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the vertical binning for a given device. This function sets the vertical binning for the device to `vbin`.\n\n @param dev Camera handle.\n @param vbin Vertical bin value. Valid values are between 1 and 16.\n @return LIBFLIAPI"]
    pub fn FLISetVBin(dev: flidev_t, vbin: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the frame type for a given device. This function sets the frame type for the device to `frametype`.\n\n @param dev Camera handle.\n @param frametype Frame type. Valid values are `FLI_FRAME_TYPE_NORMAL` (shutter open) and `FLI_FRAME_TYPE_DARK` (shutter closed).\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLISetFrameType(dev: flidev_t, frametype: fliframe_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Cancel an ongoing exposure.\n\n @param dev Camera handle.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLICancelExposure(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the remaining exposure time in milliseconds.\n\n @param dev Camera handle.\n @param timeleft Pointer to a long where the remaining exposure time will be stored.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetExposureStatus(
        dev: flidev_t,
        timeleft: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the temperature of a given device.\n\n @param dev Camera handle.\n @param temperature Temperture set point in degrees Celsius. Valid values are between -55 and 45.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLISetTemperature(dev: flidev_t, temperature: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the current temperature of a given device.\n\n @param dev Camerea handle.\n @param temperature Temperature of the camera cold finger in degrees Celsius.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetTemperature(dev: flidev_t, temperature: *mut f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the current power of the cooler in milliwatts.\n\n @param dev Device handle.\n @param power Power of the cooler in milliwatts.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetCoolerPower(dev: flidev_t, power: *mut f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Grab a row of an image. This function grabs the next available row of the image from the\n camera device `dev`. The row of width `width` is stored in the buffer pointed to by `buff`.\n The size of the buffer pointed to by `buff` must take into account the bit depth of the image,\n meaning the buffer must be at least `width` bytes long for 8-bit images and `2 * width` bytes for\n 16-bit images.\n\n @param dev Camera handle.\n @param buff Pointer to where the next row of the image will be stored.\n @param width Row width in pixels.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGrabRow(
        dev: flidev_t,
        buff: *mut ::std::os::raw::c_void,
        width: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Expose a frame for a given camera. This function exposes a frame according to\n the settings (image area, exposure time, bit depth etc.) of the camera `dev`. The settings\n of `dev` must be valid for the camera device. They are set by calling the appropriate `set`\n library functions.\n Note: This function returns after the exposure has started.\n\n @param dev Camera handle.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIExposeFrame(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Flush a number of rows for a given camera. This function flushes `rows` rows of the image\n from the camera device `dev`. The rows are flushed `repeat` times.\n\n @param dev Camera handle.\n @param rows Number of rows to flush.\n @param repeat Number of times to repeat the flush.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIFlushRow(
        dev: flidev_t,
        rows: ::std::os::raw::c_long,
        repeat: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the number of flushes for a given camera. This function sets the number of flushes\n for the camera device `dev` to `nflushes`.\n\n @param dev Camera handle.\n @param nflushes Number of flushes.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLISetNFlushes(
        dev: flidev_t,
        nflushes: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the bit depth for a given camera. This function sets the bit depth for the camera\n device `dev` to `bitdepth`.\n\n @param dev Camera handle.\n @param bitdepth Bit depth. Valid values are `FLI_MODE_8BIT` and `FLI_MODE_16BIT`.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLISetBitDepth(dev: flidev_t, bitdepth: flibitdepth_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIReadIOPort(
        dev: flidev_t,
        ioportset: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIWriteIOPort(
        dev: flidev_t,
        ioportset: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIConfigureIOPort(
        dev: flidev_t,
        ioportset: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Acquire an exclusive lock (`mutex`) on the device `dev`. This function\n prevents other threads or processes from accessing the device while the lock is held.\n\n @param dev Device handle.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLILockDevice(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Release the lock (`mutex`) on the device `dev`. This function allows other threads\n or processes to access the device.\n\n @param dev Device handle.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIUnlockDevice(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Control the shutter on a camera.\n\n @param dev Camera handle.\n @param shutter How to control the shutter. Valid values are\n    - `FLI_SHUTTER_CLOSE`: Close the shutter,\n    - `FLI_SHUTTER_OPEN`: Open the shutter,\n    - `FLI_SHUTTER_EXTERNAL_TRIGGER`: Exposure starts on logic low on `I/O[0]`,\n    - `FLI_SHUTTER_EXTERNAL_TRIGGER_LOW`: Same as `FLI_SHUTTER_EXTERNAL_TRIGGER`,\n    - `FLI_SHUTTER_EXTERNAL_TRIGGER_HIGH`: Exposure starts on logic high on `I/O[0]`. May not be available on all cameras.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIControlShutter(dev: flidev_t, shutter: flishutter_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Enables background flushing of the CCD array. This function\n enables or disables background flushing of the CCD array. The background\n flushing is stopped whenever `FLIExposeFrame()`/`FLIControlShutter()` is called.\n Note: This function is only available on some cameras.\n\n @param dev Camera handle.\n @param bgflush Enable or disable background flushing. Valid values are\n   - `FLI_BGFLUSH_STOP`: Disable background flushing,\n   - `FLI_BGFLUSH_START`: Enable background flushing.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIControlBackgroundFlush(
        dev: flidev_t,
        bgflush: flibgflush_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLISetDAC(dev: flidev_t, dacset: ::std::os::raw::c_ulong) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief List all available devices in the given domain.\n This function returns a NULL-terminated list of all\n available devices in the given domain. The list is\n stored in the variable pointed to by `names`.\n\n @param domain Domain to list devices for. Valid domains are\n  - `FLIDOMAIN_PARALLEL_PORT`,\n  - `FLIDOMAIN_USB`,\n  - `FLIDOMAIN_SERIAL`, and\n  - `FLIDOMAIN_INET`.\n Valid device types are\n  - `FLIDEVICE_CAMERA`,\n  - `FLIDOMAIN_FILTERWHEEL`, and\n  - `FLIDOMAIN_FOCUSER`.\n @param names Pointer to where the list of device names will be stored.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIList(
        domain: flidomain_t,
        names: *mut *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Free a list of device names. This function frees the memory\n allocated for the list of device names.\n\n @param names Pointer to the list of device names.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIFreeList(names: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetFilterName(
        dev: flidev_t,
        filter: ::std::os::raw::c_long,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLISetActiveWheel(
        dev: flidev_t,
        wheel: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetActiveWheel(
        dev: flidev_t,
        wheel: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLISetFilterPos(dev: flidev_t, filter: ::std::os::raw::c_long)
        -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetFilterPos(
        dev: flidev_t,
        filter: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetFilterCount(
        dev: flidev_t,
        filter: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIStepMotor(dev: flidev_t, steps: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIStepMotorAsync(
        dev: flidev_t,
        steps: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetStepperPosition(
        dev: flidev_t,
        position: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetStepsRemaining(
        dev: flidev_t,
        steps: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIHomeFocuser(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Create a list of devices in the given domain.\n Use `FLIListFirst()` and `FLIListNext()` to iterate over the list.\n Use `FLIDeleteList()` to free the list.\n\n @param domain Domain to search for devices. Valid domains are\n - `FLIDOMAIN_PARALLEL_PORT`,\n - `FLIDOMAIN_USB`,\n - `FLIDOMAIN_SERIAL`, and\n - `FLIDOMAIN_INET`.\n Supply `0` to search all domains.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLICreateList(domain: flidomain_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Delete a list of devices.\n\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIDeleteList() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the first device in the list.\n\n @param domain Pointer to the domain of the first device.\n @param filename Pointer to a character buffer where the filename of the first device will be stored.\n @param fnlen Size of the buffer pointed to by `filename`.\n @param name Pointer to a character buffer where the name of the first device will be stored.\n @param namelen Size of the buffer pointed to by `name`.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIListFirst(
        domain: *mut flidomain_t,
        filename: *mut ::std::os::raw::c_char,
        fnlen: usize,
        name: *mut ::std::os::raw::c_char,
        namelen: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the next device in the list.\n\n @param domain Pointer to the domain of the next device.\n @param filename Pointer to a character buffer where the filename of the next device will be stored.\n @param fnlen Size of the buffer pointed to by `filename`.\n @param name Pointer to a character buffer where the name of the next device will be stored.\n @param namelen Size of the buffer pointed to by `name`.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIListNext(
        domain: *mut flidomain_t,
        filename: *mut ::std::os::raw::c_char,
        fnlen: usize,
        name: *mut ::std::os::raw::c_char,
        namelen: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Retrieve temperature from a focuser device.\n\n @param dev Focuser handle.\n @param channel Temperature source. Valid values are\n - `FLI_TEMPERATURE_INTERNAL`: Internal temperature sensor,\n - `FLI_TEMPERATURE_EXTERNAL`: External temperature sensor.\n @param temperature Temperature in degrees Celsius.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIReadTemperature(
        dev: flidev_t,
        channel: flichannel_t,
        temperature: *mut f64,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetFocuserExtent(
        dev: flidev_t,
        extent: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIUsbBulkIO(
        dev: flidev_t,
        ep: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetDeviceStatus(
        dev: flidev_t,
        status: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetCameraModeString(
        dev: flidev_t,
        mode_index: flimode_t,
        mode_string: *mut ::std::os::raw::c_char,
        siz: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetCameraMode(dev: flidev_t, mode_index: *mut flimode_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLISetCameraMode(dev: flidev_t, mode_index: flimode_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIHomeDevice(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief NOT IMPLEMENTED.\n\n @param dev\n @param buff\n @param buffsize\n @param bytesgrabbed\n @return LIBFLIAPI"]
    pub fn FLIGrabFrame(
        dev: flidev_t,
        buff: *mut ::std::os::raw::c_void,
        buffsize: usize,
        bytesgrabbed: *mut usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLISetTDI(
        dev: flidev_t,
        tdi_rate: flitdirate_t,
        flags: flitdiflags_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Grab a video frame from a camera device. This function grabs a video frame from the camera device `dev` and stores it in the buffer pointed to by `buff`. The size of the buffer pointed to by `buff` must be at least `size` bytes long.\n\n @param dev Camera handle.\n @param buff Buffer where the video frame will be stored.\n @param size Size of the buffer in bytes.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGrabVideoFrame(
        dev: flidev_t,
        buff: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Stop video mode for a camera device. This function stops video mode for the camera device `dev`.\n\n @param dev Camera handle.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIStopVideoMode(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Start video mode for a camera device. This function starts video mode for the camera device `dev`.\n\n @param dev Camera handle.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIStartVideoMode(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the serial number of a device. This function copies up to `len - 1` characters of the serial number of the device to the buffer pointed to by `serial`. The string is null-terminated.\n\n @param dev Device handle.\n @param serial Pointer to a character buffer where the serial number will be stored.\n @param len Size of the buffer in bytes.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetSerialString(
        dev: flidev_t,
        serial: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief End an exposure for a given camera. This function causes the\n exposure to end and image download begins immediately.\n\n @param dev Camera handle.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIEndExposure(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Trigger an exposure for a given camera. This function triggers\n an exposure for the camera device `dev` waiting for an external\n trigger signal.\n\n @param dev Camera handle.\n @return LIBFLIAPI"]
    pub fn FLITriggerExposure(dev: flidev_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the current fan speed of a given device.\n\n @param dev Device handle.\n @param fan_speed Fan speed in RPM.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLISetFanSpeed(
        dev: flidev_t,
        fan_speed: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLISetVerticalTableEntry(
        dev: flidev_t,
        index: ::std::os::raw::c_long,
        height: ::std::os::raw::c_long,
        bin: ::std::os::raw::c_long,
        mode: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIGetVerticalTableEntry(
        dev: flidev_t,
        index: ::std::os::raw::c_long,
        height: *mut ::std::os::raw::c_long,
        bin: *mut ::std::os::raw::c_long,
        mode: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the readout dimensions of a given device. This function returns the readout dimensions of the device in the variables pointed to by `width`, `hoffset`, `hbin`, `height`, `voffset`, and `vbin`.\n\n @param dev Camera handle.\n @param width Width of the readout area.\n @param hoffset Horizontal offset of the readout area.\n @param hbin Horizontal binning of the readout area.\n @param height Height of the readout area.\n @param voffset Vertical offset of the readout area.\n @param vbin Vertical binning of the readout area.\n @return LIBFLIAPI Zero on success, non-zero error code on failure."]
    pub fn FLIGetReadoutDimensions(
        dev: flidev_t,
        width: *mut ::std::os::raw::c_long,
        hoffset: *mut ::std::os::raw::c_long,
        hbin: *mut ::std::os::raw::c_long,
        height: *mut ::std::os::raw::c_long,
        voffset: *mut ::std::os::raw::c_long,
        vbin: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIEnableVerticalTable(
        dev: flidev_t,
        width: ::std::os::raw::c_long,
        offset: ::std::os::raw::c_long,
        flags: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIReadUserEEPROM(
        dev: flidev_t,
        loc: ::std::os::raw::c_long,
        address: ::std::os::raw::c_long,
        length: ::std::os::raw::c_long,
        rbuf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FLIWriteUserEEPROM(
        dev: flidev_t,
        loc: ::std::os::raw::c_long,
        address: ::std::os::raw::c_long,
        length: ::std::os::raw::c_long,
        wbuf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
